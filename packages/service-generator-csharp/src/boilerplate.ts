import { AssetEmitter } from "@typespec/compiler/emitter-framework";
import { LibrarySourceFile } from "./interfaces.js";

export function getSerializationSourceFiles(
  emitter: AssetEmitter<string, Record<string, never>>
): LibrarySourceFile[] {
  const sourceFiles: LibrarySourceFile[] = [];
  sourceFiles.push(
    new LibrarySourceFile({
      filename: "TimeSpanDurationConverter.cs",
      emitter: emitter,
      getContents: getTimeSpanDurationConverter,
    }),
    new LibrarySourceFile({
      filename: "Base64UrlConverter.cs",
      emitter: emitter,
      getContents: getBase64UrlConverter,
    }),
    new LibrarySourceFile({
      filename: "UnixEpochDateTimeConverter.cs",
      emitter: emitter,
      getContents: getUnixEpochDateTimeConverter,
    }),
    new LibrarySourceFile({
      filename: "UnixEpochDateTimeOffsetConverter.cs",
      emitter: emitter,
      getContents: getUnixEpochDateTimeOffsetConverter,
    })
  );
  return sourceFiles;
}

function getTimeSpanDurationConverter(): string {
  return `// Copyright (c) Microsoft Corporation. All rights reserved.
  // Licensed under the MIT License.
  // <auto-generated />
  
  using System.Text.Json;
  using System.Text.Json.Serialization;
  using System.Xml;
  
  namespace TypeSpec.Helpers.JsonConverters
  {
      /// <summary>
      /// Converts between Json duration and .Net TimeSpan
      /// </summary>
      public class TimespanDurationConverter : JsonConverter<TimeSpan>
      {
          public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
          {
              if (typeToConvert != typeof(TimeSpan))
                  throw new ArgumentException($"Cannot apply converter {this.GetType().FullName} to type {typeToConvert.FullName}");
  
              var value = reader.GetString();
              if (string.IsNullOrWhiteSpace(value)) return TimeSpan.MinValue;
              return XmlConvert.ToTimeSpan(value);
          }
  
          public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options)
          {
              writer.WriteStringValue(XmlConvert.ToString(value));
          }
      }
  }
  `;
}

function getBase64UrlConverter(): string {
  return `// Copyright (c) Microsoft Corporation. All rights reserved.
  // Licensed under the MIT License.
  // <auto-generated />

  using System.Text.Json;
  using System.Text.Json.Serialization;
  
  namespace TypeSpec.Helpers.JsonConverters
  {
      /// <summary>
      /// System.Text.Json converter for the properties using Base64Url encoding
      /// </summary>
      public class Base64UrlJsonConverter : JsonConverter<byte[]>
      {
          /// <summary>
          /// Adds padding to the input
          /// </summary>
          /// <param name="input"> the input string </param>
          /// <returns> the padded string </returns>
          private static string Pad(string input)
          {
              var count = 3 - ((input.Length + 3) % 4);
              if (count == 0)
              {
                  return input;
              }
              return $"{input}{new string('=', count)}";
          }
  
          public override byte[]? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
          {
              if (typeToConvert != typeof(byte[])) throw new ArgumentException($"Cannot apply converter {this.GetType().FullName} to type {typeToConvert.FullName}");
              var value = reader.GetString();
              if (string.IsNullOrWhiteSpace(value)) return null;
              return Convert.FromBase64String(Pad(value.Replace('-', '+').Replace('_', '/')));
          }
  
          public override void Write(Utf8JsonWriter writer, byte[] value, JsonSerializerOptions options)
          {
              writer.WriteStringValue(Convert.ToBase64String(value).TrimEnd('=').Replace('+', '-').Replace('/', '_'));
          }
      }
  }
  `;
}

function getUnixEpochDateTimeConverter(): string {
  return `// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// <auto-generated />

  using System.Text.Json;
  using System.Text.Json.Serialization;
  
  namespace TypeSpec.Helpers.JsonConverters
  {
      /// <summary>
      /// Converts between an integer timestamp and a .Net DateTime
      /// </summary>
      public sealed class UnixEpochDateTimeConverter : JsonConverter<DateTime>
      {
          static readonly DateTime s_epoch = new DateTime(1970, 1, 1, 0, 0, 0);
  
          public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
          {
              var formatted = reader.GetInt64()!;
              return s_epoch.AddMilliseconds(formatted);
          }
  
          public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
          {
              long unixTime = Convert.ToInt64((value - s_epoch).TotalMilliseconds);
              writer.WriteNumberValue(unixTime);
          }
      }
  }
  `;
}

function getUnixEpochDateTimeOffsetConverter(): string {
  return `// Copyright (c) Microsoft Corporation. All rights reserved.
  // Licensed under the MIT License.
  // <auto-generated />
  
  using System.Text.Json;
  using System.Text.Json.Serialization;
  
  namespace TypeSpec.Helpers.JsonConverters
  {
      /// <summary>
      /// Converts between a Unix TimeStamp and a .Net DateTimeOffset
      /// </summary>
      public sealed class UnixEpochDateTimeOffsetConverter : JsonConverter<DateTimeOffset>
      {
          static readonly DateTimeOffset s_epoch = new DateTimeOffset(1970, 1, 1, 0, 0, 0, TimeSpan.Zero);
         
  
          public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
          {
              var formatted = reader.GetInt64()!;
              return s_epoch.AddMilliseconds(formatted);
          }
  
          public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
          {
              long unixTime = Convert.ToInt64((value - s_epoch).TotalMilliseconds);
              writer.WriteNumberValue(unixTime);
          }
      }
  }
  `;
}
